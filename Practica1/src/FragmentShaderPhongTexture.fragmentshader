#version 330 core

#define NUM_MAX_PLIGHTS 4
#define NUM_MAX_SLIGHTS 4

struct Material {
    sampler2D diffuse;
    sampler2D specular;
    float     shininess;
};

struct PLight {
  	vec3 position;
	
	vec3 ambient;
	vec3 diffuse;
	vec3 specular;
	
	float constant
	float linear;
	float quadratic;
};

struct DLight {
    vec3 direction;
  
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
};

struct SLight {
	vec3 position;
	vec3 direction;
	
	vec3 ambient;
    vec3 diffuse;
//  vec3 specular;
	
	float constant
	float linear;
	float quadratic;
	
	vec3 innerConeRadius;
	vec3 outerConeRadius;
	

};

in vec3 FragPos;  
in vec3 Normal;  
in vec2 TexCoords;
  
out vec4 color;
  
uniform vec3 viewPos;
uniform Material material;
uniform DLight dlight;
uniform PLight plight[NUM_MAX_PLIGHTS];
uniform SLight slight[NUM_MAX_SLIGHTS];

<<<<<<< HEAD
=======
vec3 DirectionalLight(DLight light, vec3 Normal, vec3 viewDir);
vec3 PointLight      (PLight light, vec3 Normal, vec3 viewDir);
vec3 SpotLight       (SLight light, vec3 Normal, vec3 viewDir);

>>>>>>> origin/master
void main()
{
  //SUMA DE TODAS LAS LUCES:
//  vec3 output;
//  output += DirectionalLight(dlight, Normal);
//  for(int i = 0; i < NUM_MAX_PLIGHTS; i++)
//  	output += PointLight();
//  for(int i = 0; i < NUM_MAX_SLIGHTS; i++)
//	output += SpotLight();
  
<<<<<<< HEAD
  color = vec3(0.5, 0.5, 0.5);
=======
  color = vec3(0.1, 0.1, 0.1);
}

vec3 DirectionalLight(DLight light, vec3 Normal, vec3 viewDir){
	vec3 light.direction = normalize(-light.direction)
    // Componente iluminacion difusa:
    float diff = max(dot(Normal, lightDir), 0.0);
    // Componente iluminacion especular:
    vec3 reflectDir = reflect(lightDir, Normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
    // Combinacion de resultados:
    vec3 ambient  = light.ambient  * vec3(texture(material.diffuse, TexCoords));
    vec3 diffuse  = light.diffuse  * diff * vec3(texture(material.diffuse, TexCoords));
    vec3 specular = light.specular * spec * vec3(texture(material.specular, TexCoords));
    return (ambient + diffuse + specular);
}

vec3 PointLight(PLight light, vec3 Normal, vec3 viewDir){
    vec3 lightDir = normalize(light.position - fragPos);
    // Componente iluminacion difusa:
    float diff = max(dot(Normal, lightDir), 0.0);
    // Componente iluminacion especular:
    vec3 reflectDir = reflect(-lightDir, Normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
    // Componente de atenuacion:
    float distance    = length(light.position - fragPos);
    float attenuation = 1.0f / (light.constant + light.linear * distance + light.quadratic * (distance * distance));    
    // Combinacion de resultados:
    vec3 ambient  = light.ambient  * vec3(texture(material.diffuse, TexCoords));
    vec3 diffuse  = light.diffuse  * diff * vec3(texture(material.diffuse, TexCoords));
    vec3 specular = light.specular * spec * vec3(texture(material.specular, TexCoords));
    ambient  *= attenuation;
    diffuse  *= attenuation;
    specular *= attenuation;
    return (ambient + diffuse + specular);
}

vec3 SpotLight(SLight light, vec3 Normal, vec3 viewDir){
	//Necesitamos algunos valores iniciales antes, para calcular la iluminacion focal:
	//El siguiente vector lo he sacado del espacio que hay en iluminacion difusa, ya que necesitamos calcularlo antes:
	vec3 lightDir = normalize(light.position - FragPos); //Obtener vector direccion NORMALIZADO de la luz.

	float theta = dot(lightDir, normalize(-light.direction)); //Obtener Theta, es un angulo obtenido multiplicando el vector que relaciona la posicion de la camara con la posicion del fragmento, por la direccion del foco en este caso.
	
	//Variables para calcular la intensidad luminica entre el radio interior y exterior del cono luminico del spot light
	float epsilon = light.innerConeRadius - light.outerConeRadius;
	float intensity = clamp((theta - outerConeRadius) /epsilon, 0.0, 1.0);
	
	//Los if son un una condicion de la iluminacion focal, las tecnicas de iluminacion son las mismas.
	if(theta > outerConeRadius) //El fragmento esta dentro del foco: Esto es lo mismo que decir si el vector LightDir apunta a un fragmento que esta fuera del foco, por lo tanto sabemos que el fragmento esta dentro o fuera del alcance del foco.
	{        //Por cierto, solo con cambiar inner outerConeRadius a innerConeRadius aplicamos o no el difuminado externo.

		//4.Calculo Iluminacion difusa:
		vec3 norm = normalize(Normal); //Normalizar la normal de la cara del cubo.
		//En esta linea se calcularia la direccion de la luz, pero ya lo hemos hecho en el principio del main.
		float diff = max(dot(norm, lightDir), 0.0); //El dot product entre la normal y la direccion de la luz nos da la intensidad de la luz diusa (El angulo entre los 2 vectores previos). La funcion max se asegura de que el resultado no sea negativo (Color negativo wtf).
		vec3 diffuse = diff * lightColor; //Esta intensidad la multiplicamos por el color de la luz y nos da parte del color que queremos mostrar en esa cara del cubo.
		diffuse *= intensity;
		vec3 diffuseResult = (light.ambient + light.diffuse) * vec3(texture(material.diffuse, TexCoords)); //El color final es el color difuso + el ambiente calculado en '3' * el color base del objeto.
			
		return diffuseResult;
	}
	else //El fragmento esta fuera del foco: Usar iluminacion ambiental unicamente:
	{
		return light.ambient;
	}
>>>>>>> origin/master
}